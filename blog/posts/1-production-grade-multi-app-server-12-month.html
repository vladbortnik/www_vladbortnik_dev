<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month | Vlad Bortnik</title>
    <meta name="description" content="Learn how to host multiple production apps on a $12/month VPS with Docker, Nginx, and enterprise-level security. Save $240-480/year on hosting costs.">
    <meta name="keywords" content="Docker, DevOps, Nginx, DigitalOcean, VPS, Production Server, Multi-App Hosting, SSL, Infrastructure">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://vladbortnik.dev/blog/posts/production-grade-multi-app-server-12-month.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://vladbortnik.dev/blog/posts/production-grade-multi-app-server-12-month.html">
    <meta property="og:title" content="Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month">
    <meta property="og:description" content="Learn how to host multiple production apps on a $12/month VPS with Docker, Nginx, and enterprise-level security. Save $240-480/year on hosting costs.">
    <meta property="og:image" content="https://vladbortnik.dev/assets/img/brand-logo.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Vlad Bortnik - Software Engineer Portfolio">
    <meta property="og:site_name" content="Vlad Bortnik Portfolio">
    <meta property="og:locale" content="en_US">
    <meta property="article:published_time" content="2025-11-03T00:00:00-04:00">
    <meta property="article:modified_time" content="2025-11-03T00:00:00-04:00">
    <meta property="article:author" content="https://vladbortnik.dev">
    <meta property="article:section" content="DevOps">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="Nginx">
    <meta property="article:tag" content="DevOps">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://vladbortnik.dev/blog/posts/production-grade-multi-app-server-12-month.html">
    <meta name="twitter:title" content="Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month">
    <meta name="twitter:description" content="Learn how to host multiple production apps on a $12/month VPS with Docker, Nginx, and enterprise-level security. Save $240-480/year on hosting costs.">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" sizes="16x16 32x32" href="../../assets/img/favicon.ico">

    <!-- RSS Feed Auto-Discovery -->
    <link rel="alternate" type="application/rss+xml" title="Vlad Bortnik's Blog RSS Feed" href="https://vladbortnik.dev/blog/feed.xml">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

    <!-- Vendor CSS Files -->
    <link href="../../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="../../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">

    <!-- Main CSS Files -->
    <link href="../../assets/css/style.css" rel="stylesheet">
    <link href="../assets/css/blog.css?v=10" rel="stylesheet">

    <!-- Prism.js for Syntax Highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-dracula.min.css" rel="stylesheet">

    <!-- Structured Data - Enhanced Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month",
        "description": "Learn how to host multiple production apps on a $12/month VPS with Docker, Nginx, and enterprise-level security. Save $240-480/year on hosting costs.",
        "image": {
            "@type": "ImageObject",
            "url": "https://vladbortnik.dev/assets/img/brand-logo.png",
            "width": 1200,
            "height": 1200
        },
        "author": {
            "@type": "Person",
            "name": "Vlad Bortnik",
            "url": "https://vladbortnik.dev",
            "sameAs": [
                "https://twitter.com/vladbortnik_dev",
                "https://github.com/vladbortnik",
                "https://linkedin.com/in/vladbortnik"
            ]
        },
        "publisher": {
            "@type": "Organization",
            "name": "Vlad Bortnik",
            "logo": {
                "@type": "ImageObject",
                "url": "https://vladbortnik.dev/assets/img/brand-logo.png",
                "width": 512,
                "height": 512
            }
        },
        "datePublished": "2025-11-03",
        "dateModified": "2025-11-03",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://vladbortnik.dev/blog/posts/production-grade-multi-app-server-12-month.html"
        },
        "keywords": "Docker, DevOps, Nginx, DigitalOcean, VPS, SSL, LetsEncrypt, Infrastructure, Production Server",
        "proficiencyLevel": "Intermediate",
        "dependencies": "Docker, Nginx, Ubuntu, PostgreSQL"
    }
    </script>

    <!-- BreadcrumbList Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [{
            "@type": "ListItem",
            "position": 1,
            "name": "Home",
            "item": "https://vladbortnik.dev"
        },{
            "@type": "ListItem",
            "position": 2,
            "name": "Blog",
            "item": "https://vladbortnik.dev/blog/"
        },{
            "@type": "ListItem",
            "position": 3,
            "name": "Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month",
            "item": "https://vladbortnik.dev/blog/posts/production-grade-multi-app-server-12-month.html"
        }]
    }
    </script>
</head>

<body>
    <!-- Reading Progress Bar -->
    <div class="reading-progress"></div>

    <!-- ======= HEADER ======= -->
    <header id="header" class="header-top">
        <div class="container">
            <h1><a href="/">Vlad Bortnik</a></h1>

            <nav id="navbar" class="navbar">
                <ul>
                    <li><a class="nav-link" href="/">Home</a></li>
                    <li><a class="nav-link" href="/#about">About</a></li>
                    <li><a class="nav-link" href="/#portfolio">Projects</a></li>
                    <li><a class="nav-link" href="/#resume">Resume</a></li>
                    <li><a class="nav-link active" href="/blog/">Blog</a></li>
                    <li><a class="nav-link" href="/contact.html">Contact</a></li>
                </ul>
                <i class="bi bi-list mobile-nav-toggle"></i>
            </nav>
        </div>
    </header>

    <!-- ======= Blog Post ======= -->
    <section id="blog-post" class="blog-post">
        <div class="container">

            <a href="/blog/" class="back-to-blog">
                <i class="bi bi-arrow-left"></i> Back to Blog
            </a>

            <div class="blog-post-content">

                <!-- Post Header -->
                <div class="blog-post-header">
                    <h1>Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month</h1>

                    <div class="post-meta">
                        <div>
                            <i class="bi bi-calendar3"></i>
                            <span>November 3, 2025</span>
                        </div>
                        <div>
                            <i class="bi bi-clock"></i>
                            <span>22 min read</span>
                        </div>
                        <div>
                            <i class="bi bi-person"></i>
                            <span>Vlad Bortnik</span>
                        </div>
                        <span class="post-category">DevOps</span>
                    </div>
                </div>

                <!-- Article Content -->
                <div class="article-content">
<h1>Deploy Like a Pro: Production-Grade Multi-Application Server for $12/Month</h1>

<p><em>A practical guide to escaping expensive hosting by building your own production-grade infrastructure on DigitalOceanâ€”complete with Docker, Nginx, and Enterprise-Level security.</em></p>

<hr>

<img src="../../assets/img/blog/server-setup/server-setup-title-img-overlay.jpg" alt="Article screenshot" loading="lazy">

<h2>The Problem That Started Everything</h2>

<p>I was running three web applications: my portfolio site, a recipe app, and a book exchange platform. Between Heroku ($7/app), database hosting, and custom domains with SSL, I was paying $45/month with frustrating limitations. No WebSocket support. Restrictive resource limits. Complex SSL setup. Every time I wanted to deploy a new project, I&#39;d calculate the cost and hesitate.</p>

<p>The breaking point came when I realized I was paying more for hosting than for the actual domain names. There had to be a better way.</p>

<p><strong>This guide shows you how to host multiple production applications on a single $12/month VPS</strong> with A+ security ratings, sub-100ms response times, and complete control over your infrastructure.</p>

<p>This isn&#39;t a theoretical guide. These are the actual configurations I use in production, the mistakes I made along the way, and the lessons I learned debugging at 2 AM when my server went down.</p>

<p>By the end, you&#39;ll understand:</p>

<ul>
	<li>How to set up a secure production server from scratch</li>
	<li>How to configure Nginx as a reverse proxy for multiple apps</li>
	<li>How to implement Docker network segregation for security</li>
	<li>How to obtain and configure wildcard SSL certificates</li>
	<li>How to achieve A+ security ratings on a budget VPS</li>
</ul>

<p>Let me be honest: <strong>this takes time to set up</strong>. But the skills you&#39;ll learn and the money you&#39;ll save make it worth every minute.</p>

<hr>

<h2>The Complete Architecture (What I Actually Built)</h2>

<p>Here&#39;s what my final setup looks like. This diagram represents everything I&#39;m going to walk you through:</p>

<img src="../../assets/img/blog/server-setup/server-setup-diagram.webp" alt="Article screenshot" loading="lazy">

<p><em>My complete production infrastructure: DigitalOcean droplet with Nginx reverse proxy, Docker containers, network segregation, and SSL termination</em></p>

<p>The architecture has several layers:</p>

<ul>
	<li><strong>External Layer</strong>: Nginx handles all incoming HTTP/HTTPS traffic</li>
	<li><strong>Application Layer</strong>: Docker containers running isolated web applications</li>
	<li><strong>Network Layer</strong>: Custom Docker bridges for secure internal communication</li>
	<li><strong>Data Layer</strong>: PostgreSQL databases isolated from the internet</li>
	<li><strong>Security Layer</strong>: Fail2Ban, UFW firewall, and Let&#39;s Encrypt SSL</li>
</ul>

<p>Let me be honest: I didn&#39;t build this all at once. It evolved over several weeks of experimentation, reading documentation, and fixing things that broke. But now that it&#39;s running, it&#39;s been rock solid.</p>

<hr>

<h2>Planning: What You Actually Need</h2>

<p>Before touching any server, I mapped out my requirements:</p>

<p><strong>Essential requirements:</strong></p>

<ul>
	<li>Multiple application hosting with isolation (Docker with network segregation)</li>
	<li>Custom domain and subdomains (<a href="https://recipe.vladbortnik.dev">recipe.vladbortnik.dev</a>, <a href="https://tldrx.vladbortnik.dev">tldrx.vladbortnik.dev</a>, etc.)</li>
	<li>Free SSL certificate covering the domain and all subdomains</li>
	<li>Separate database per application</li>
	<li>Production-grade security</li>
	<li>Room for scaling</li>
</ul>

<p><strong>Budget reality check:</strong></p>

<ul>
	<li>DigitalOcean Droplet (2GB RAM): $12/month</li>
	<li>Automated backups: $2.40/month</li>
	<li>Domain names: ~$3/month (yearly cost divided)</li>
	<li><strong>Total: ~$17/month</strong></li>
</ul>

<p>Compare this to platform alternatives where three apps with databases cost $35-60/month minimum. <strong>That&#39;s $240-480 in annual savings</strong>.</p>

<p>The math made sense, but the real question was: could I actually pull this off?</p>

<hr>

<h2>Tech Stack Decisions (And Why I Made Them)</h2>

<h3>Ubuntu 24.04 LTS</h3>

<p>I chose Ubuntu because <a href="https://www.digitalocean.com/community/tutorials">DigitalOcean&#39;s documentation</a> is excellent for it, and the LTS version means stability for years. No surprises, no breaking updates. If you&#39;re new to DigitalOcean, their <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-ubuntu-server-on-a-digitalocean-droplet">Droplet creation guide</a> walks through the entire process.</p>

<h3>Nginx as Reverse Proxy</h3>

<p>Nginx became the heart of my setup. It sits at the front, handling all incoming traffic and routing it to the right application. Here&#39;s what it does:</p>

<ul>
	<li>Routes traffic to different applications based on domain/subdomain</li>
	<li>Terminates SSL (handles HTTPS encryption/decryption)</li>
	<li>Provides load balancing when I need it</li>
	<li>Caches static content automatically</li>
</ul>

<p>The key insight: <strong>Nginx is your traffic cop</strong>. All HTTP/HTTPS requests hit Nginx first, and it decides where they go.</p>

<p>For deeper understanding, check out the <a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">Official Nginx Reverse Proxy Documentation</a> and this excellent <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html">Nginx Proxy Module Reference</a>.</p>

<h3>Docker for Application Isolation</h3>

<p>Docker solved my &quot;works on my machine&quot; problem. Each application runs in its own container with its own dependencies, Python version, and configuration. If one app crashes, the others keep running.</p>

<p>The <a href="https://docs.docker.com/get-started/">Docker Documentation</a> is excellent for understanding containerization concepts, and <a href="https://docs.docker.com/compose/networking/">Docker Compose Networking</a> explains how containers communicate securely.</p>

<hr>

<h2>Initial Server Setup: The Foundation</h2>

<p>I started with <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu">DigitalOcean&#39;s initial server setup guide</a>, but let me highlight what actually matters:</p>

<h3>1. Create a Non-Root User</h3>

<p>Never run things as root in production. Ever.</p>

<pre><code class="language-bash">adduser yourusername
usermod -aG sudo yourusername</code></pre>

<h3>2. SSH Key Authentication (Critical)</h3>

<p>Set up SSH keys and disable password login. This was the first real security measure that made me feel like I was doing things right:</p>

<pre><code class="language-bash"># On your local machine
ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;

# Copy to server
ssh-copy-id yourusername@your_server_ip</code></pre>

<p>Then disable password authentication in <code>/etc/ssh/sshd_config</code>:</p>

<pre><code class="language-bash">PasswordAuthentication no</code></pre>

<h3>3. UFW Firewall Configuration</h3>

<p>This is where I almost locked myself out. <strong>Critical lesson: Always allow SSH before enabling the firewall.</strong></p>

<img src="../../assets/img/blog/server-setup/ufw-status.png" alt="Article screenshot" loading="lazy">

<p><em>UFW firewall configuration showing only essential ports open</em></p>

<pre><code class="language-bash">sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow OpenSSH  # CRITICAL: Allow SSH before enabling firewall
sudo ufw allow 80/tcp   # HTTP
sudo ufw allow 443/tcp  # HTTPS
sudo ufw enable

# Verify firewall status
sudo ufw status</code></pre>

<h3>4. Fail2Ban for Brute Force Protection</h3>

<p>Fail2Ban monitors logs and bans IPs after failed login attempts. My configuration bans after three failures:</p>

<pre><code class="language-bash">sudo apt install fail2ban
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</code></pre>

<p>In <code>/etc/fail2ban/jail.local</code>:</p>

<pre><code class="language-ini">[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 86400  # 24 hours</code></pre>

<p>Within a week, Fail2Ban had blocked 47 IP addresses trying to brute force their way in. It works.</p>

<p>For more details on Fail2Ban setup, see this <a href="https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-22-04">Comprehensive Guide from DigitalOcean</a>.</p>

<hr>

<h2>Docker Installation: Getting the Foundation Right</h2>

<p>I initially tried installing Docker the &quot;easy&quot; way and ran into permission errors. Here&#39;s what actually works:</p>

<pre><code class="language-bash"># Update package index
sudo apt update
sudo apt install -y apt-transport-https ca-certificates curl software-properties-common

# Add Docker&#39;s official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Set up Docker repository
echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# Install Docker Engine
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# Add user to docker group
sudo usermod -aG docker ${USER}
su - ${USER}  # Re-login to apply group changes

# Verify installation
docker --version
docker compose version</code></pre>

<p><strong>Personal note:</strong> I initially forgot to add my user to the docker group and spent an hour troubleshooting &quot;permission denied&quot; errors. Always run that <code>usermod</code> command!</p>

<p>For the complete installation guide, see <a href="https://docs.docker.com/get-started/">Docker&#39;s Official Installation Docs</a> or this <a href="https://www.digitalocean.com/community/tutorials">Excellent DigitalOcean Docker Tutorial</a>.</p>

<hr>

<h2>Nginx Configuration: The Deep Dive</h2>

<p>This is where theory met reality. Let me show you the actual configurations I use, not simplified examples.</p>

<h3>Understanding Nginx as a Reverse Proxy</h3>

<p>A reverse proxy sits between clients and your application servers. Here&#39;s what actually happens:</p>

<ol>
	<li>Client makes request to <code>https://recipe.vladbortnik.dev</code></li>
	<li>Nginx receives it, terminates SSL, and forwards to <code>http://localhost:5002</code></li>
	<li>My Flask app running in Docker at port <code>5002</code> responds</li>
	<li>Nginx sends the response back to the client</li>
</ol>

<p>The client never talks directly to my application. This provides security (hides backend architecture), enables SSL termination, allows caching, and simplifies backend maintenance.</p>

<img src="../../assets/img/blog/server-setup/reverse-proxy.png" alt="Article screenshot" loading="lazy">

<p><em>Nginx reverse proxy configuration showing SSL termination and proxy headers</em></p>

<h3>Basic Reverse Proxy Configuration</h3>

<p>Here&#39;s my actual configuration for a single application:</p>

<pre><code class="language-nginx"># HTTP server - redirects everything to HTTPS
server {
    listen 80;
    listen [::]:80;  # IPv6 support

    server_name recipe.vladbortnik.dev;

    location / {
        return 301 https://$host$request_uri;  # Permanent redirect to HTTPS
    }
}

# HTTPS server - the real deal
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name recipe.vladbortnik.dev;

    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/vladbortnik.dev/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/vladbortnik.dev/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;

    # Modern TLS configuration
    ssl_protocols TLSv1.3;
    ssl_prefer_server_ciphers off;

    # HSTS - tells browsers to always use HTTPS
    add_header Strict-Transport-Security &quot;max-age=63072000&quot; always;

    # Security headers
    add_header X-Frame-Options &quot;SAMEORIGIN&quot; always;
    add_header X-Content-Type-Options &quot;nosniff&quot; always;
    add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot; always;
    add_header Permissions-Policy &quot;camera=(), microphone=(), geolocation=(), payment=()&quot; always;

    # Content Security Policy - customize based on your needs
    add_header Content-Security-Policy &quot;default-src &#39;self&#39; data:; img-src &#39;self&#39; data: blob:; font-src &#39;self&#39; data:;&quot; always;

    # Root directory (if serving static files)
    root /var/www/recipe.vladbortnik.dev/html;

    # Reverse proxy to application
    location / {
        proxy_pass http://localhost:5002;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</code></pre>

<p><strong>What each header does (honestly explained):</strong></p>

<ul>
	<li><code>Host:</code>Preserves the original domain name</li>
	<li><code>X-Real-IP:</code>The visitor&#39;s actual IP (important for logging)</li>
	<li><code>X-Forwarded-For:</code>Complete chain if there are multiple proxies</li>
	<li><code>X-Forwarded-Proto:</code>Tells your app if the original request was HTTP or HTTPS</li>
</ul>

<p>For more details on these proxy headers and settings, check the <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html">Nginx Proxy Module Documentation</a>.</p>

<h3>Server Blocks: Hosting Multiple Domains</h3>

<img src="../../assets/img/blog/server-setup/server-blocks.png" alt="Article screenshot" loading="lazy">

<p><em>Multiple Nginx server blocks for hosting different applications on different subdomains</em></p>

<p>Server blocks (virtual hosts) let you host multiple domains on one server. Each subdomain gets its own configuration file in <code>/etc/nginx/sites-available/</code>:</p>

<pre><code class="language-bash"># Create configuration file
sudo nano /etc/nginx/sites-available/recipe.vladbortnik.dev

# Enable it by symlinking to sites-enabled
sudo ln -s /etc/nginx/sites-available/recipe.vladbortnik.dev /etc/nginx/sites-enabled/

# Test configuration (ALWAYS do this)
sudo nginx -t

# Reload if test passes
sudo systemctl reload nginx</code></pre>

<p>I organize my configs like this:</p>

<pre><code>/etc/nginx/
â”œâ”€â”€ sites-available/
â”‚   â”œâ”€â”€ recipe.vladbortnik.dev
â”‚   â”œâ”€â”€ tldrx.vladbortnik.dev
â”‚   â””â”€â”€ portfolio.vladbortnik.dev
â””â”€â”€ sites-enabled/
    â”œâ”€â”€ recipe.vladbortnik.dev -&gt; ../sites-available/recipe.vladbortnik.dev
    â”œâ”€â”€ tldrx.vladbortnik.dev -&gt; ../sites-available/tldrx.vladbortnik.dev
    â””â”€â”€ vladbortnik.dev -&gt; ../sites-available/vladbortnik.dev</code></pre>

<p>This keeps things organized and makes it easy to disable a site without deleting the config.</p>

<h3>Load Balancing: When One Instance Isn&#39;t Enough</h3>

<p>When my recipe app started getting traffic, a single instance couldn&#39;t handle peak loads. Load balancing distributes traffic across multiple application instances.</p>

<img src="../../assets/img/blog/server-setup/load-balancer.png" alt="Article screenshot" loading="lazy">

<p><em>Load balancer configuration distributing traffic across three application instances</em></p>

<p>Here&#39;s my production load balancer configuration:</p>

<pre><code class="language-nginx"># Define upstream servers (backend application instances)
upstream recipe_app {
    ip_hash;  # Ensures same client IP always goes to same server (session-friendly)

    server localhost:5002 max_fails=3 fail_timeout=30s;
    server localhost:5003 max_fails=3 fail_timeout=30s;
    server localhost:5004 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name recipe.vladbortnik.dev;

    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name recipe.vladbortnik.dev;

    # [SSL configuration same as above]

    location / {
        proxy_pass http://recipe_app;  # Routes to upstream group
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</code></pre>

<p><strong>Key points about this setup:</strong></p>

<ul>
	<li><code>ip_hash</code> ensures users stay on the same backend server (important for sessions)</li>
	<li><code>max_fails=3</code> means Nginx will mark a server as down after 3 failed attempts</li>
	<li><code>fail_timeout=30s</code> is how long before Nginx tries the failed server again</li>
	<li>Health checks are automaticâ€”Nginx removes unhealthy servers from rotation</li>
</ul>

<p>For more on load balancing algorithms and strategies, see the <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html">Nginx upstream module documentation</a>.</p>

<hr>

<h2>Docker Configuration: Application Isolation Done Right</h2>

<p>Docker was intimidating at first, but it&#39;s worth the learning curve. Here&#39;s how I structured things.</p>

<h3>Network Segregation: The Security Game-Changer</h3>

<p>The biggest security win in my setup: <strong>databases never talk directly to the internet</strong>. They&#39;re on a private Docker network accessible only by application containers.</p>

<img src="../../assets/img/blog/server-setup/networks-diagram.png" alt="Article screenshot" loading="lazy">

<p><em>Docker network architecture: databases on backend network, web services bridging frontend and backend</em></p>

<p>Here&#39;s the network diagram that illustrates this critical concept. Notice how:</p>

<ul>
	<li><strong>Frontend Network</strong> (public): Connects web services to the host/Nginx</li>
	<li><strong>Backend Network</strong> (private): Connects web services to databases only</li>
	<li><strong>Databases</strong>: NO connection to frontend network = NO internet exposure</li>
</ul>

<p>This is defense in depth. Even if UFW fails, the database cannot be reached from the internet.</p>

<p>For deeper understanding of Docker networking, check out <a href="https://docs.docker.com/compose/networking/">Docker&#39;s Networking Documentation</a> and <a href="https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html">OWASP Docker Security Best Practices</a>.</p>

<h3>Docker Compose for Simple Single-Instance App</h3>

<p>For a basic setup with one application instance:</p>

<pre><code class="language-yaml">services:
  web:
    build: .
    command: gunicorn -w 4 -b 0.0.0.0:5002 run:app
    volumes:
      - .:/code
    ports:
      - &quot;5002:5002&quot;
    env_file:
      - .env
    depends_on:
      - db
      - migration
    restart: unless-stopped
    mem_limit: 384m
    mem_reservation: 192m
    cpus: 0.3

  migration:
    build: .
    command: ./scripts/wait-for-migrations.sh
    volumes:
      - .:/code
    env_file:
      - .env
    depends_on:
      - db
    restart: &quot;no&quot;

  db:
    image: postgres:16.4
    volumes:
      - postgres_data:/var/lib/postgresql/data
    env_file:
      - .env
    ports:
      - &quot;5432:5432&quot;
    restart: unless-stopped
    mem_limit: 384m
    mem_reservation: 192m
    cpus: 0.3

volumes:
  postgres_data:</code></pre>

<h3>Docker Compose for Load-Balanced Setup</h3>

<p>When load balancing, things get more complex. Here&#39;s my production configuration with network segregation:</p>

<pre><code class="language-yaml"># Network Segregation
networks:
  frontend:  # Public-facing network
  backend:   # Private, internal network

services:
  # Web Application Instance 1
  web1:
    build: .
    command: gunicorn -w 4 -b 0.0.0.0:5002 run:app
    networks:
      - frontend  # For communication with Internet
      - backend   # For communication with DB only
    ports:
      - &quot;5002:5002&quot;  # The only necessary external port
    env_file:
      - .env
    depends_on:
      - db
    mem_limit: 384m              # Hard limit - container killed if exceeded
    mem_reservation: 192m        # Soft limit - guaranteed available
    cpus: 0.3                    # Limit to 30% of one CPU core
    restart: unless-stopped

  # Web Application Instance 2
  web2:
    build: .
    command: gunicorn -w 4 -b 0.0.0.0:5002 run:app
    networks:
      - frontend
      - backend
    ports:
      - &quot;5003:5002&quot;  # Host port 5003 maps to container port 5002
    env_file:
      - .env
    depends_on:
      - db
    mem_limit: 384m
    mem_reservation: 192m
    cpus: 0.3
    restart: unless-stopped

  # Web Application Instance 3
  web3:
    build: .
    command: gunicorn -w 4 -b 0.0.0.0:5002 run:app
    networks:
      - frontend
      - backend
    ports:
      - &quot;5004:5002&quot;
    env_file:
      - .env
    depends_on:
      - db
    mem_limit: 384m
    mem_reservation: 192m
    cpus: 0.3
    restart: unless-stopped

  # PostgreSQL Database (Backend Network - Internal Only)
  db:
    image: postgres:16.4
    volumes:
      - postgres_data:/var/lib/postgresql/data
    env_file:
      - .env
    networks:
      - backend  # Only Web Service has access to DB
    # ports:       # Port is NOT exposed to the host (Isolated from Internet)
    #   - &#39;5432:5432&#39;
    mem_limit: 384m
    mem_reservation: 192m
    cpus: 0.3
    restart: unless-stopped

volumes:
  postgres_data:  # Persistent storage for PostgreSQL data
</code></pre>

<p><strong>Critical insight:</strong> Notice the database has no port mapping to the host. It&#39;s only accessible via the <code>backend</code> network. The web containers connect using the service name: <code>postgresql://db:5432/database_name</code> instead of <code>localhost:5432</code>.</p>

<p>For more on resource constraints and why they matter, see <a href="https://docs.docker.com/config/containers/resource_constraints/">Docker&#39;s Resource Constraints Documentation</a>.</p>

<h3>Resource Limits: Preventing Cascade Failures</h3>

<p>I learned this the hard way: without resource limits, one misbehaving container can crash your entire server. Memory limits and CPU restrictions prevent this:</p>

<pre><code class="language-yaml">mem_limit: 384m         # Hard limit - container gets killed if exceeded
mem_reservation: 192m   # Soft limit - guaranteed minimum
cpus: 0.3               # 30% of one CPU core
</code></pre>

<p>With three application instances and a database, I&#39;m using about 1.5GB of my 2GB RAM, leaving room for system processes and spikes.</p>

<img src="../../assets/img/blog/server-setup/docker-stats.png" alt="Article screenshot" loading="lazy">

<p><em>Real-time Docker container resource usage showing memory and CPU limits in action</em></p>

<hr>

<h2>SSL/TLS Configuration: The DNS-01 Challenge Story</h2>

<p>Most guides recommend HTTP-01 challenge for Let&#39;s Encrypt SSL certificates. I went with DNS-01 instead, and here&#39;s why.</p>

<h3>Why DNS-01 Made Sense for My Setup</h3>

<p>With Nginx terminating HTTPS and routing based on subdomains, I needed wildcard certificates. DNS-01 is the only challenge type that supports wildcards: <code>*.vladbortnik.dev</code>.</p>

<p><strong>The three Let&#39;s Encrypt challenge types:</strong></p>

<ol>
	<li><strong>HTTP-01</strong>: Requires serving a file at <code>http://yourdomain.com/.well-known/acme-challenge/</code></li>
	<li><strong>DNS-01</strong>: Requires adding a TXT record to your DNS</li>
	<li><strong>TLS-ALPN-01</strong>: Requires port 443 to be available (least common)</li>
</ol>

<p>DNS-01 meant one certificate could cover:</p>

<ul>
	<li>vladbortnik.dev</li>
	<li>recipe.vladbortnik.dev</li>
	<li>tldrx.vladbortnik.dev</li>
	<li>bookfinder.vladbortnik.dev</li>
	<li>(any future subdomain)</li>
</ul>

<p>For a comprehensive explanation of challenge types, see <a href="https://letsencrypt.org/docs/challenge-types/">Let&#39;s Encrypt&#39;s Challenge Types Documentation</a>.</p>

<h3>Setting Up Certbot with DNS-01</h3>

<p>I use DigitalOcean for DNS, so I used the Certbot DigitalOcean plugin:</p>

<pre><code class="language-bash">sudo snap install --classic certbot
sudo snap set certbot trust-plugin-with-root=ok
sudo snap install certbot-dns-digitalocean

# Create API token file
sudo mkdir -p /root/.secrets/certbot
sudo nano /root/.secrets/certbot/digitalocean.ini</code></pre>

<p>In <code>digitalocean.ini</code>:</p>

<pre><code class="language-ini">dns_digitalocean_token = your_digitalocean_api_token_here</code></pre>

<pre><code class="language-bash"># Secure the file
sudo chmod 600 /root/.secrets/certbot/digitalocean.ini

# Request wildcard certificate
sudo certbot certonly \
  --dns-digitalocean \
  --dns-digitalocean-credentials /root/.secrets/certbot/digitalocean.ini \
  -d vladbortnik.dev \
  -d *.vladbortnik.dev

# Enable automatic renewal
sudo systemctl enable snap.certbot.renew.timer

# Test renewal
sudo certbot renew --dry-run</code></pre>

<img src="../../assets/img/blog/server-setup/certbot-certificates.png" alt="Article screenshot" loading="lazy">

<p><em>Certbot SSL certificates showing wildcard coverage for all subdomains</em></p>

<p>Auto-renewal is handled by a snap timer. The certificate renews automatically 30 days before expiration.</p>

<p>For detailed Certbot setup instructions, see the <a href="https://certbot.eff.org/instructions">Official Certbot Documentation</a>.</p>

<h3>Achieving A+ Security Rating</h3>

<p>Getting an A+ on SSL Labs required proper SSL configuration. Here&#39;s what matters:</p>

<img src="../../assets/img/blog/server-setup/ssl-lab-test-score.png" alt="Article screenshot" loading="lazy">

<p><em>SSL Labs test showing A rating for production-grade TLS configuration</em></p>

<pre><code class="language-nginx"># Modern TLS only (no outdated protocols)
ssl_protocols TLSv1.3;
ssl_prefer_server_ciphers off;

# Session configuration
ssl_session_timeout 1d;
ssl_session_cache shared:MozSSL:10m;
ssl_session_tickets off;

# HSTS - force HTTPS for 2 years
add_header Strict-Transport-Security &quot;max-age=63072000&quot; always;

# Security headers
add_header X-Frame-Options &quot;SAMEORIGIN&quot; always;
add_header X-Content-Type-Options &quot;nosniff&quot; always;
add_header Referrer-Policy &quot;strict-origin-when-cross-origin&quot; always;

# Content Security Policy - start strict, loosen as needed
add_header Content-Security-Policy &quot;default-src &#39;self&#39; data:; img-src &#39;self&#39; data: blob:; font-src &#39;self&#39; data:;&quot; always;</code></pre>

<img src="../../assets/img/blog/server-setup/security-headers-score.png" alt="Article screenshot" loading="lazy">

<p><em>Security Headers test showing A+ rating with comprehensive HTTP security headers</em></p>

<p><strong>Honest note about CSP:</strong> Content Security Policy is powerful but can break your site if too strict. I started with a permissive policy and gradually tightened it by checking browser console errors.</p>

<p>For SSL/TLS configuration best practices, see <a href="https://nginx.org/en/docs/http/configuring_https_servers.html">Nginx&#39;s HTTPS Configuration Guide</a> and test your config at <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a>.</p>

<img src="../../assets/img/blog/server-setup/http-observatory-score.png" alt="Article screenshot" loading="lazy">

<p><em>Mozilla HTTP Observatory showing A+ overall security score</em></p>

<hr>

<h2>Deployment Workflow: The Practical Reality</h2>

<h3>Manual Deployment First</h3>

<p>I deploy manually using FileZilla (SFTP client) for the first few iterations of any project. Here&#39;s why:</p>

<ol>
	<li>It helps me understand what&#39;s actually happening</li>
	<li>I can debug issues more easily</li>
	<li>No CI/CD complexity until I need it</li>
</ol>

<p><strong>FileZilla Setup:</strong></p>

<ul>
	<li>Download from <a href="https://filezilla-project.org/">filezilla-project.org</a></li>
	<li>Connect with SFTP protocol</li>
	<li>Host: your_server_ip</li>
	<li>Username: your_ssh_user</li>
	<li>Key file: your SSH private key</li>
</ul>

<p>I upload files to <code>/home/username/apps/project-name/</code>, then SSH in and run:</p>

<pre><code class="language-bash">cd /home/username/apps/project-name
docker-compose build
docker-compose up -d</code></pre>

<p>For detailed FileZilla usage, see their <a href="https://wiki.filezilla-project.org/Using">Official Documentation</a>.</p>

<h3>Automation Later (GitHub Actions)</h3>

<p>Once the manual process works smoothly, automate it. But don&#39;t start with automationâ€”you&#39;ll spend hours debugging CI/CD instead of debugging your actual application.</p>

<hr>

<h2>Monitoring and Maintenance: The Real Cost</h2>

<p>Setting up the server is one thing. Keeping it running is another.</p>

<h3>Essential Monitoring Tools</h3>

<p><strong>UptimeRobot (free):</strong> Pings my sites every 5 minutes and emails me if they&#39;re down. Has saved me twice when processes crashed. Sign up at <a href="https://uptimerobot.com/">uptimerobot.com</a>.</p>

<p><strong>Netdata (free):</strong> Real-time system monitoring. I can see CPU, memory, disk usage, and network traffic in beautiful dashboards. Install with:</p>

<pre><code class="language-bash">bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh)</code></pre>

<p>Access at <code>http://your_server_ip:19999</code></p>

<p>Learn more at <a href="https://www.netdata.cloud/">netdata.cloud</a>.</p>

<p><strong>Sentry (optional):</strong> For application error tracking and monitoring. Great for production apps. Check it out at <a href="https://sentry.io/welcome/">sentry.io</a>.</p>

<h3>Regular Maintenance Tasks</h3>

<p><strong>Weekly checklist:</strong></p>

<ul>
	<li>Check disk usage: <code>$ df -h</code></li>
	<li>Review Nginx logs: <code>$ sudo tail -f /var/log/nginx/error.log</code></li>
	<li>Verify backups are running</li>
</ul>

<p><strong>Monthly checklist:</strong></p>

<ul>
	<li>Update system packages: <code>$ sudo apt update &amp;&amp; sudo apt upgrade</code></li>
	<li>Review Fail2Ban logs: <code>$ sudo fail2ban-client status sshd</code></li>
	<li>Check Docker disk usage: <code>$ docker system df</code></li>
</ul>

<p><strong>Quarterly:</strong></p>

<ul>
	<li>Test backup restoration (crucialâ€”untested backups are useless)</li>
	<li>Review and rotate old logs</li>
	<li>Audit user access and SSH keys</li>
</ul>

<img src="../../assets/img/blog/server-setup/docker-ps.png" alt="Article screenshot" loading="lazy">

<p><em>Docker containers running in production showing uptime and health status</em></p>

<h3>Automated Updates</h3>

<p>I use unattended-upgrades for security updates:</p>

<pre><code class="language-bash">sudo apt install unattended-upgrades
sudo dpkg-reconfigure --priority=low unattended-upgrades</code></pre>

<p>This automatically installs security patches but not major version upgrades (which could break things).</p>

<hr>

<h2>Performance Optimization: What Actually Worked</h2>

<h3>Nginx Caching for Static Assets</h3>

<p>This one setting dramatically improved load times:</p>

<pre><code class="language-nginx">location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff2|svg)$ {
    expires 30d;
    add_header Cache-Control &quot;public, immutable&quot;;
}</code></pre>

<p>Static assets are cached for 30 days. Page load time dropped from 1.2s to 400ms.</p>

<h3>Gzip Compression</h3>

<p>Enable in <code>/etc/nginx/nginx.conf</code>:</p>

<pre><code class="language-nginx">gzip on;
gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;</code></pre>

<p>This reduces transfer sizes by 60-70% for text-based resources.</p>

<p>For more performance optimization techniques, see the <a href="https://www.nginx.com/blog/nginx-caching-guide/">Nginx Caching Guide</a> and consider <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/">Cloudflare CDN</a> for further improvements.</p>

<h3>Database Connection Pooling</h3>

<p>Using SQLAlchemy with proper connection pooling:</p>

<pre><code class="language-python"># In your Flask app config
SQLALCHEMY_ENGINE_OPTIONS = {
    &#39;pool_size&#39;: 10,
    &#39;pool_recycle&#39;: 3600,
    &#39;pool_pre_ping&#39;: True,
}</code></pre>

<p>This prevents the &quot;too many connections&quot; error I hit during traffic spikes.</p>

<hr>

<h2>Cost Analysis: 6 Months Later</h2>

<p><strong>Actual monthly costs:</strong><br/></p>

<ul>
	<li>DigitalOcean Droplet: <code>$12</code></li>
	<li>Automated backups: <code>$2.40</code></li>
	<li>Domain names (3 domains): <code>$3</code></li>
	<li><strong>Total: <code>$17.40/month</code></strong></li>
</ul>

<p><strong>Current resource usage:</strong><br/></p>

<ul>
	<li>CPU: 15-20% average, 40% peak</li>
	<li>RAM: 1.3GB of 2GB used (65%)</li>
	<li>Storage: 9GB of 25GB used</li>
	<li><strong>Could easily host 2-3 more applications</strong></li>
</ul>

<p><strong>Compared to platform hosting for 3 apps:</strong><br/></p>

<ul>
	<li>Heroku: <code>$39/month</code></li>
	<li>Render: <code>$35/month</code></li>
	<li>Railway: <code>$20/month</code></li>
</ul>

<p><strong>Monthly savings: <code>$20-30</code></strong></p>

<p><strong>Yearly savings: <code>$240-360</code></strong></p>

<p>Plus I learned skills worth far more than the savings.</p>

<hr>

<h2>Common Issues and How I Fixed Them</h2>

<h3>Issue: Application Can&#39;t Connect to Database</h3>

<p><strong>Error:</strong> <code>psycopg2.OperationalError: could not connect to server</code></p>

<p><strong>Solution:</strong> Check your Docker networks. The database container must be on the same network as the application. In your app, use the service name: <code>postgresql://db:5432/dbname</code>, not <code>localhost:5432</code>.</p>

<h3>Issue: Nginx Shows 502 Bad Gateway</h3>

<p><strong>Debugging steps:</strong></p>

<ol>
	<li>Check if application is running: <code>docker ps</code></li>
	<li>Check application logs: <code>docker logs container_name</code></li>
	<li>Verify port numbers match between Docker and Nginx config</li>
	<li>Test application directly: <code>curl http://localhost:5002</code></li>
</ol>

<p>Most common cause: Application crashed, wrong port number, or firewall blocking the port.</p>

<h3>Issue: SSL Certificate Won&#39;t Renew</h3>

<p><strong>Check renewal status:</strong></p>

<pre><code class="language-bash">sudo certbot renew --dry-run</code></pre>

<p>With DNS-01, ensure your DigitalOcean API token is still valid and has proper permissions.</p>

<p>For comprehensive SSL troubleshooting, check <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-20-04">DigitalOcean&#39;s Let&#39;s Encrypt Guide</a>.</p>

<hr>

<h2>What I&#39;d Do Differently</h2>

<p>If I started over today:</p>

<ol>
	<li><strong>Document as you build</strong>: I spent hours remembering what commands I ran. Keep a log.</li>
	<li><strong>Start with one app</strong>: Don&#39;t try to migrate everything at once. Get one app working perfectly, then add others.</li>
	<li><strong>Backups from day one</strong>: I waited two weeks before setting up backups. That was stupid. Automate backups immediately.</li>
	<li><strong>Use Ansible/Terraform</strong>: For anything beyond 1-2 servers, infrastructure-as-code is worth the learning curve.</li>
	<li><strong>Monitoring before problems</strong>: Install monitoring before you have issues, not after your site goes down.</li>
</ol>

<hr>

<h2>The Honest Truth About Self-Hosting</h2>

<p><strong>What you gain:</strong></p>

<ul>
	<li>Complete control over your infrastructure</li>
	<li>Significant cost savings</li>
	<li>Deep understanding of how web services work</li>
	<li>Confidence to debug production issues</li>
	<li>Flexibility to host unlimited projects</li>
</ul>

<p><strong>What you lose:</strong></p>

<ul>
	<li>Managed service convenience</li>
	<li>Automatic scaling (you handle it manually)</li>
	<li>Someone else to blame when things break</li>
	<li>Some evenings and weekends debugging</li>
</ul>

<p><strong>Is it worth it?</strong> For me, absolutely. The skills I gained are more valuable than the time invested. I can confidently deploy any project, optimize performance, and fix issues without depending on platform support.</p>

<p>But be realistic: if you just want to ship features and don&#39;t care about infrastructure, use a platform. Self-hosting is for people who enjoy the infrastructure layer, for portfolio projects, etc.</p>

<hr>

<h2>Resources and Next Steps</h2>

<p><strong>Essential documentation:</strong></p>

<ul>
	<li><a href="https://www.digitalocean.com/community/tutorials">DigitalOcean Community Tutorials</a></li>
	<li><a href="https://nginx.org/en/docs/">Nginx Documentation</a></li>
	<li><a href="https://docs.docker.com/">Docker Documentation</a></li>
	<li><a href="https://letsencrypt.org/docs/">Let&#39;s Encrypt Documentation</a></li>
</ul>

<p><strong>My complete configurations:</strong></p>

<ul>
	<li>All the configs, scripts, and detailed documentation are in my GitHub repository: <a href="https://github.com/vladbortnik/production-server-infrastructure">Production-Server-Infrastructure</a>. </li>
	<li>You may also check up the <strong>Project</strong> at my <a href="https://vladbortnik.dev/server-setup.html">Portfolio Website</a>.</li>
</ul>

<p><strong>Testing your SSL configuration:</strong></p>

<ul>
	<li><a href="https://www.ssllabs.com/ssltest/">SSL Labs Server Test</a></li>
	<li><a href="https://observatory.mozilla.org/">Mozilla Observatory</a></li>
	<li><a href="https://securityheaders.com/">Security Headers</a></li>
</ul>

<p><strong>Additional Resources:</strong></p>

<p>For deeper learning about modern application architecture, I highly recommend <a href="https://12factor.net/">The Twelve-Factor App</a> methodology.</p>

<hr>

<h2>Conclusion: Build It and Learn</h2>

<p>I started this project to save money on hosting. I ended up with something far more valuable: a deep understanding of production web infrastructure.</p>

<p>The setup I described isn&#39;t theoreticalâ€”it&#39;s running in production right now. It has survived traffic spikes, minor DDoS attempts, and my own configuration mistakes.</p>

<p>Your journey will look different. You&#39;ll make different choices, encounter different problems, and find different solutions. That&#39;s the point. Self-hosting isn&#39;t about following a perfect recipe; it&#39;s about understanding the ingredients well enough to adapt when things go wrong.</p>

<p>Start small. Deploy one application. Break things. Fix them. Learn. Then scale up.</p>

<p><strong>The best time to start was six months ago. The second best time is now.</strong></p>

<hr>

<h2>Get in Touch</h2>

<p>Questions about this setup? Find me at:</p>

<ul>
	<li><a href="https://vladbortnik.dev/">Portfolio</a></li>
	<li><a href="https://github.com/vladbortnik">GitHub</a></li>
	<li><a href="https://www.linkedin.com/in/vladbortnik/">LinkedIn</a></li>
	<li><a href="https://x.com/vladbortnik_dev">X/Twitter</a></li>
	<li><a href="https://vladbortnik.dev/contact.html">Contact me</a></li>
</ul>

<p>I&#39;m happy to help troubleshoot or discuss infrastructure approaches. We&#39;re all learning together.</p>

<hr>

<p><em>ðŸ¤– This infrastructure has been running in production for 6+ months, hosting multiple applications with 99.9% uptime. All configurations shown are production-tested.</em></p>
                </div>

                <!-- Author Bio -->
                <section class="author-bio">
                    <img src="../../assets/img/vlad-bortnik-headshot.jpg" alt="Vlad Bortnik - Backend Software Engineer specializing in Python, Docker, and DevOps" width="1121" height="1121" loading="lazy" class="author-photo">
                    <div class="author-info">
                        <h3>About the Author</h3>
                        <h4>Vlad Bortnik</h4>
                        <p>Backend software engineer specializing in Python/Flask, Docker, DevOps, and cloud infrastructure. Passionate about building scalable, production-grade web applications and sharing knowledge with the developer community.</p>
                        <div class="author-links">
                            <a href="https://github.com/vladbortnik" target="_blank" rel="noopener"><i class="bi bi-github"></i> GitHub</a>
                            <a href="https://linkedin.com/in/vladbortnik" target="_blank" rel="noopener"><i class="bi bi-linkedin"></i> LinkedIn</a>
                            <a href="https://x.com/vladbortnik_dev" target="_blank" rel="noopener"><i class="bi bi-twitter-x"></i> X/Twitter</a>
                        </div>
                    </div>
                </section>

            </div>
        </div>
    </section>

    <!-- ======= Footer ======= -->
    <footer id="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-icons">
                    <a href="https://github.com/vladbortnik" target="_blank" rel="noopener" class="github">
                        <i class="bi bi-github"></i>
                    </a>
                    <a href="https://linkedin.com/in/vladbortnik" target="_blank" rel="noopener" class="linkedin">
                        <i class="bi bi-linkedin"></i>
                    </a>
                    <a href="https://x.com/vladbortnik_dev" target="_blank" rel="noopener" class="twitter">
                        <i class="bi bi-twitter-x"></i>
                    </a>
                </div>
                <div class="footer-copyright">
                    Â© 2025 Vlad Bortnik. All rights reserved.
                </div>
            </div>
        </div>
    </footer>

    <!-- Vendor JS Files -->
    <script src="../../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-nginx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-ini.min.js"></script>

    <!-- Main JS -->
    <script src="../../assets/js/main.js"></script>

    <!-- Reading Progress Bar -->
    <script>
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.querySelector('.reading-progress').style.width = scrolled + '%';
        });
    </script>

</body>
</html>
